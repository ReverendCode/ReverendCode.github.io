<html>
<head>
<script src="js/three.min.js"></script>
<script src="js/render.js"></script>

<script id="vertShader" type="shader">
// varying vec2 vUv;
varying vec3 vecPos;
varying vec3 vecNormal;
void main() {
    // vUv = uv;
    // This should set vecPos to be the location of the vertex in (roughly) world space
    vecPos = (modelMatrix * vec4(position, 1.0)).xyz;
    vecNormal = normalMatrix * normal;

    gl_Position = projectionMatrix *
                  modelViewMatrix * vec4(position, 1.0 );
}
</script>

<script id="fragShader" type="shader">
precision highp float;
// varying vec2 vUv;
varying vec3 vecPos;
varying vec3 vecNormal;
uniform vec3 diffuse;

uniform float color;
uniform vec3 pointLightColor[NUM_POINT_LIGHTS];
uniform vec3 pointLightPosition[NUM_POINT_LIGHTS];//not really a position.
uniform float pointLightDistance[NUM_POINT_LIGHTS];

void main(void) {

	// initialize your light accumulator
	vec3 vNormal = normalize(vecNormal);
	vec4 lightDirectionSum = vec4(0.0,0.0,0.0,1.0);
	vec4 Red = vec4(1.0,0.0,0.0,1.0);

	for (int i = 0; i < NUM_POINT_LIGHTS; i++) {
		vec3 lightDir = normalize(vecPos - pointLightPosition[i]);
		lightDirectionSum.rgb += clamp(dot(-lightDir, vNormal),0.0, 1.0) * pointLightColor[i];
	}
	float steps = 4.0;
	// gl_FragColor = mix(vec4(1.0,0.0,0.0, 1.0),lightDirectionSum,lightDirectionSum);
	// fprintf("%f",lightDirectionSum);
	float intensity = ceil(clamp(lightDirectionSum.r 
		+ lightDirectionSum.g 
		+ lightDirectionSum.b, 0.0, 1.0) * steps) / steps;
	// gl_FragColor = Red + vec4(intensity);
	gl_FragColor = vec4(diffuse, 1.0) + vec4(intensity);
}
</script>

</head>
<body style="margin: 0px;" onload="init()"></body>
</html>